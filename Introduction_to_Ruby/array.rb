配列について
→存在しない要素を指定してもエラーにならず、nilが返る。
[例]
a = [1, 2, 3]
a[3] #=> nil



→配列内の特定の位置にある要素を削除する場合はdelete_atメソッドを使う。
[例]
a = [1, 2, 3]
# 2番目の要素を削除する(削除した値が戻り値になる)
a.delete_at(1) 　#=> 2
a             　 #=> [1, 3]

# 存在しないインデックスを指定するとnilが返る
a.delete_at(100) #=> nil
a                #=> [1, 3]




多重代入
→左辺の変数に * をつけるとはみ出した値が切り捨てられず残りの全要素を配列として受け取ることができる。
残りの要素を全て無視したい場合は * の後の変数名を省略できる。
* は左辺に対する変数がない残りの要素が代入されるので要素が１つもなければからの配列が返る。
[例] 配列を使って多重代入する
a, b = [1, 2]
a #=> 1
b #=> 2

[例] 右辺の数が少ない時はnilが入る
c, d = [10]
c #=> 10
d #=> nil

[例] 右辺の数が多い時ははみ出した値が切り捨てられる
e, f = [100, 200, 300]
e #=> 100
f #=> 200

[例] * を使った多重代入
e, *f = 100, 200, 300
e #=> 100
f #=> [200, 300]

[例] 100だけeに格納して、200と300を無視する
e, * = 100, 200, 300
e #=> 100

[例] * を省略して200と300を無視できるがあまり使用用途がない
e, = 100, 200, 300
e #=> 100

[例] * を使った配列の多重代入の応用パターン
a, *b, c, d = 1, 2, 3, 4, 5
a #=> 1
b #=> [2, 3]
c #=> 4
d #=> 5

[例] 1がa, 2がc, 3がdに対応する、右辺に残りの要素がなくなったのでbはからの配列になる
a, *b, c, b = 1, 2, 3
a #=> 1
b #=> []
c #=> 2
d #=> 3
