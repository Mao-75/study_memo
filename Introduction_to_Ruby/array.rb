配列について
→存在しない要素を指定してもエラーにならず、nilが返る。
[例]
a = [1, 2, 3]
a[3] #=> nil



→配列内の特定の位置にある要素を削除する場合はdelete_atメソッドを使う。
[例]
a = [1, 2, 3]
# 2番目の要素を削除する(削除した値が戻り値になる)
a.delete_at(1) 　#=> 2
a             　 #=> [1, 3]

# 存在しないインデックスを指定するとnilが返る
a.delete_at(100) #=> nil
a                #=> [1, 3]



→値を変更する場合も負のインデックスを使用できる、ただし元の大きさを超えるようなインデックスを指定するとエラーになる。
[例]
a = [1, 2, 3]
a[-3] = -10
a #=> [-10, 2, 3]

[例] 指定可能な負の値よりも小さくなるとエラーが発生する
a[-4] = 0 #=> index -4 too small for array; minimum: -3 (IndexError)



→インデックスを２つ使うとインデックスの位置を取得する長さを指定できる。
配列[位置, 取得する長さ]

[例]
a = [1, 2, 3, 4, 5]
a[1, 3] #=> [2, 3, 4]



→[配列の長さ - 1]を指定すれば最後の要素を取得できる。
  Rubyではインデックスに負の値が使える。
[例]
a = [1, 2, 3]
a[a.size - 1]#=> 3

[例] インデックスに負の値を使う
a = [1, 2, 3]
a[-1]   #=> 3
a[-2]   #=> 2

[例] 最後から２番目の要素から２つの要素を取得する
a[-2, 2] #=> [2, 3]



→開始位置と長さを指定して要素を置き換えることも可能。
[例]
a = [1, 2, 3, 4, 5]
# ２つ目から３要素分を100で置き換える
a[1, 3] = 100
a #=>[1, 100, 5]


→　<<だけでなくpushメソッドでも要素を追加できる、pushメソッドの場合複数の値を追加できる。
[例]
a = []
a.push(1)
a.push(2, 3)
a #=> [1, 2, 3]

[例] 
# pushメソッドで配列を追加した場合、２つの要素ではなく１つの配列として追加される。
a = []
b = [2, 3]
a.push(1) #=> a[1]
a.push(b) #=> [1, [2, 3]]



→メソッドの引数に配列を渡すとき、「１つの配列」ではなく「複数の引数」として渡したい場合は配列の前に * (splat演算子)を置く。
[例]
a = []
b = [2, 3]
a.push(1) #=> a[1]
a.push(*b) #=> [1, 2, 3]



→case文やwhen節で * を使って配列を複数の条件として展開できる。
[例]
ja = ['japan', '日本']
country = 'japan'
case country
# *により配列が展開され、when 'japan', '日本の'を書いたものと同じ意味になる
whan *ja
  'こんにちは'
end
#=> "こんにちは"



→配列で | は和集合を求める演算子、２つの配列の要素を全て集めて重複しないようにして返す。
[例]
a = [1, 2, 3]
b = [3, 4, 5]
a | b #=> [1, 2, 3, 4, 5]



多重代入
→左辺の変数に * をつけるとはみ出した値が切り捨てられず残りの全要素を配列として受け取ることができる。
残りの要素を全て無視したい場合は * の後の変数名を省略できる。
* は左辺に対する変数がない残りの要素が代入されるので要素が１つもなければからの配列が返る。
[例] 配列を使って多重代入する
a, b = [1, 2]
a #=> 1
b #=> 2

[例] 右辺の数が少ない時はnilが入る
c, d = [10]
c #=> 10
d #=> nil

[例] 右辺の数が多い時ははみ出した値が切り捨てられる
e, f = [100, 200, 300]
e #=> 100
f #=> 200

[例] * を使った多重代入
e, *f = 100, 200, 300
e #=> 100
f #=> [200, 300]

[例] 100だけeに格納して、200と300を無視する
e, * = 100, 200, 300
e #=> 100

[例] * を省略して200と300を無視できるがあまり使用用途がない
e, = 100, 200, 300
e #=> 100

[例] * を使った配列の多重代入の応用パターン
a, *b, c, d = 1, 2, 3, 4, 5
a #=> 1
b #=> [2, 3]
c #=> 4
d #=> 5

[例] 1がa, 2がc, 3がdに対応する、右辺に残りの要素がなくなったのでbはからの配列になる
a, *b, c, b = 1, 2, 3
a #=> 1
b #=> []
c #=> 2
d #=> 3
