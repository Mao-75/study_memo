sprintfメソッド
→指定されたフォーマットの文字列を作成するメソッド
[例1] 1.2の小数第３位まで数字を表示する文字列を作成
sprintf('%0.3f', 1.2) #=> "1.200"

[例2] フォーマット文字列 % 表示したいオブジェクト の形式でも同じ結果が得られる
'%0.3f' % 1.2 #=> "1.200"

[例3] 表示したいオブジェクトを複数渡すこともできる
sprintf('%0.3f + %0.3f', 1.2, 0.48) #=> "1.200 + 0.480"
'%0.3f + %0.3f' % [1.2, 0.48]       #=> "1.200 + 0.480"



putsメソッド
→putsメソッドは最後に改行を加えて変数の内容やメソッドの戻り値を出力する。
putsメソッドの戻り値は nil になる。
改行文字を含む文字列を渡したとき改行して出力される。
[例]
puts 123
123
#=> nil                                           

puts 'abc'
abc
# => nil

[例] 改行文字を含む文字列を渡した場合
s = "abc\nefg"

puts s
abc
efg                                              
#=> nil


printメソッド
→printメソッドは改行を加えない。
改行文字を含む文字列を渡したとき改行して出力される。
[例]
print 123
123=> nil

print 'abc'
abc=> nil

[例] 改行文字を含む文字列を渡した場合
s = "abc\nefg"

print s
abc
efg=> nil



pメソッド
→pメソッドはputsメソッドと同じように改行を加えて出力する。
だだし、文字列を出力するとその文字列がダブルクオートで囲まれている点がputsメソッドと異なる。
また、pメソッドは引数で渡されたオブジェクトそのものがメソッドの戻り値になる。
改行文字を含む文字列を渡したとき改行文字が改行文字のまま出力される。
[例]
p 123
123
#=> 123                                           

p 'abc'
"abc"
#=> "abc"

[例] 改行文字を含む文字列を渡した場合
s = "abc\nefg"

p s
"abc\nefg"
=> "abc\nefg"



ppメソッド
→ppメソッドは大きくて複雑な配列やハッシュ、オブジェクトの内容を見やすく整形して出力する。
pメソッドでは内容がごちゃごちゃしていて確認しづらい時にppメソッドを使うと便利な場合がある。
pメソッドと同様にppメソッドも引数として渡したオブジェクトがそのままメソッドの戻り値になる。
[例]
# pメソッドではネストした配列が横並びになってしまい確認しづらい
p Encoding.aliases.take(5)
#=> [["BINARY", "ASCII-8BIT"], ["CP437", "IBM437"], ["CP720", "IBM720"], ["CP737", "IBM737"], ["CP775", "IBM775"]]

[例]
# ppメソッドを使うと配列が見やすく整形される
pp Encoding.aliases.take(5)
#=> [["BINARY", "ASCII-8BIT"],
#=> ["CP437", "IBM437"],
#=> ["CP720", "IBM720"],
#=> ["CP737", "IBM737"],
#=> ["CP775", "IBM775"]]

[例]
# 引数として渡したオブジェクトがそのままメソッドの戻り値になる
pp 'abc'
"abc"
#=> "abc"



→putsメソッドとprintメソッドは引数で渡されたオブジェクトに対してto_sメソッドを呼び出して文字列に変換している。
pメソッドとppメソッドはto_sメソッドではなくinspectメソッドを呼び出している。
文字列がダブルクオートで囲まれて出力されたのは、内部的にStringクラスのinpectメソッドが呼び出されその値が出力されている。
[例]
# 文字列をinspectすると、ダブルクオート付きの文字列が返る
'abc'.inspect #=> "\"abc\""



values_atメソッド
→取得したい要素のインデックスを複数指定できる。
[例]
a = [1, 2, 3, 4, 5]
a.values_at(0, 2, 4) #=> [1, 3, 5]



firstメソッド
→先頭の要素を取得する。
[例]
a = [1, 2, 3]
a.first #=> 1
a.first(2) #=> [1, 2]



lastメソッド
→配列の最後の要素を取得できる、引数に引数に0以上の数値を渡すと最後のn個の要素を取得できる。
[例]
a = [1, 2, 3]
a.last #=> 3
a.last(2) #=> [2, 3]



mapメソッド
→mapメソッドは各要素に対してブロックを評価した結果を新しい配列にして返す(エイリアスメソッドがcollect)
[例] eachメソッドの場合
numbers = [1, 2, 3, 4, 5]
new_numbers = []
numbers.each { |n| new_numbers << n * 10 }

new_numbers #=> [10, 20, 30, 40, 50]

→mapメソッドを使うとブロックの戻り値が配列の要素となる新しい配列が作成されるため、
戻り値をそのまま新しい変数に入れることができる。
→空の配列を用意して他の配列をループ処理した結果を空の配列に詰め込んでいくような処理の大半はmapメソッドに置き換えることができる。
[例]
numbers = [1, 2, 3, 4, 5]
# ブロックの戻り値が新しい配列の各要素になる
new_numbers = numbers.map { |n| n * 10 }

new_numbers #=> [10, 20, 30, 40, 50]



selectメソッド
→selectメソッド(エイリアスメソッドはfind_all)は各要素に対してブロックを評価し、その戻り値が真の要素を集めた配列を返すメソッド。
[例]
numbers = [1, 2, 3, 4, 5, 6]
# ブロックの戻り値が真になった要素だけが集められる
even_numbers = numbers.select { |n| n.even? }
even_numbers #=> [2, 4, 6]



rejectメソッド
→rejectメソッドはselectメソッドの反対で、ブロックの戻り値が真になった要素を除外した配列を返す、ブロックの戻り値が偽である要素を集めるメソッド。
[例]
numbers = [1, 2, 3, 4, 5, 6]
# 3の倍数を除外する(３の倍数以外を集める)
non_multiples_of_three = numbers.reject { |n| n % 3 == 0 }
non_multiples_of_three #=> [2, 4, 6]
