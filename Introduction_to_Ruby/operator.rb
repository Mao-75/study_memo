!(NOT)演算子
→真偽値を反転することができる、真が偽に、偽が真になる。
[例]
t1 = true
f1 = false
!t1         #=> false
!f1         #=> true

# t1が真でかつ、f1が真の場合に真を返す、と言う意味。
t1 && f1    #=> false

# t1が真でかつ、f1が偽の場合に真を返す、と言う意味。
!(t1 && f1) #=> true


ビット演算
→整数値は演算子を使ってビット演算(整数値の２進表現に対応したビット列に関する演算)ができる。
[例] &　 ビットごとの論理積(AND)
# '%#b' は、結果を2進数で表現する際に、先頭に "0b" を付けることを指定している。
sprintf '%#b', (0b1010 & 0b1100) #=> "0b1000"


[例] |　ビットごとの論理和(OR)
sprintf '%#b', (0b1010 | 0b1100) #=> "0b1110"


[例] ^　ビットごとの排他的論理和(XOR)
sprintf '%#b', (0b1010 ^ 0b1100) #=> "0b110"


[例] >>　右ビットにシフト
sprintf '%#b', (0b1010 >> 1) #=> "0b101"


[例] <<　左ビットにシフト
sprintf '%#b', (0b1010 << 1) #=> "0b10100"


[例] ~　 ビットごとに論理反転(NOT)
# ..1 は左側に１が無限に続くことを表す。
sprintf '%#b', ~0b1010 #=> "0b..10101"


and, or, notの優先順位
→and, or, not は && , || , ! に近い働きをする演算子だが、
 and, or, not は && , || , ! に比べて優先順位が低いので全く同じように使うことはできない。

t1 = true
t2 = true
f1 = false

# ! は || よりも優先順位が高い。
[例] !f1 || t1       #=> true

# not は || よりも優先順位が低い。
[例] not f1 || ti    #=> false

# &&の方が優先順位が高い、最初にt2 && f1 が評価され、その結果がt1 || の右側に影響を与えてtrue が返される。
[例] t1 || t2 && f1  #=> true

# andとorの優先順位は同じなので左から順に評価される。
[例] t1 or t2 and f1 #=> false
