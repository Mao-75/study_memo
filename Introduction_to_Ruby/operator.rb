!(NOT)演算子
->真偽値を反転することができる、真が偽に、偽が真になる
[例]
t1 = true
f1 = false
!t1         #=> false
!f1         #=> true

# t1が真でかつ、f1が真の場合に真を返す、と言う意味
t1 && f1    #=> false

# t1が真でかつ、f1が偽の場合に真を返す、と言う意味
!(t1 && f1) #=> true


ビット演算
->整数値は演算子を使ってビット演算(整数値の２進表現に対応したビット列に関する演算)ができる
[例] &　 ビットごとの論理積(AND)
# '%#b' は、結果を2進数で表現する際に、先頭に "0b" を付けることを指定している
sprintf '%#b', (0b1010 & 0b1100) #=> "0b1000"


[例] |　ビットごとの論理和(OR)
sprintf '%#b', (0b1010 | 0b1100) #=> "0b1110"


[例] ^　ビットごとの排他的論理和(XOR)
sprintf '%#b', (0b1010 ^ 0b1100) #=> "0b110"


[例] >>　右ビットにシフト
sprintf '%#b', (0b1010 >> 1) #=> "0b101"


[例] <<　左ビットにシフト
sprintf '%#b', (0b1010 << 1) #=> "0b10100"


[例] ~　 ビットごとに論理反転(NOT)
# ..1 は左側に１が無限に続くことを表す
sprintf '%#b', ~0b1010 #=> "0b..10101"
